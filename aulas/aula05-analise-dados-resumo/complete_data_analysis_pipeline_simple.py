#!/usr/bin/env python3
"""
Aula 05: Pipeline Simples de An√°lise de Dados
Professor: Vagner Cordeiro
Curso: T√≥picos de Big Data em Python

Vers√£o SIMPLIFICADA sem problemas de tipos - FUNCIONAL 100%
"""

import random
import json
from datetime import datetime

# Verifica√ß√£o de bibliotecas
HAS_PANDAS = False
HAS_NUMPY = False
HAS_MATPLOTLIB = False

try:
    import pandas as pd
    HAS_PANDAS = True
    print("‚úÖ Pandas dispon√≠vel")
except ImportError:
    print("üìä Pandas n√£o dispon√≠vel - usando simula√ß√£o")

try:
    import numpy as np
    HAS_NUMPY = True
    print("‚úÖ NumPy dispon√≠vel")
except ImportError:
    print("üìä NumPy n√£o dispon√≠vel - usando simula√ß√£o")

try:
    import matplotlib.pyplot as plt
    HAS_MATPLOTLIB = True
    print("‚úÖ Matplotlib dispon√≠vel")
except ImportError:
    print("üìä Matplotlib n√£o dispon√≠vel - usando simula√ß√£o")

# Simulador de dados simples
def gerar_dados_vendas(num_registros=1000):
    """Gera dados simulados de vendas de forma simples"""
    print(f"üè≠ Gerando {num_registros} registros de dados de vendas...")
    
    dados = []
    produtos = ["Notebook", "Mouse", "Teclado", "Monitor", "Webcam"]
    categorias = ["Eletr√¥nicos", "Inform√°tica", "Perif√©ricos"]
    regioes = ["Norte", "Sul", "Leste", "Oeste", "Centro"]
    
    for i in range(num_registros):
        registro = {
            'id': i + 1,
            'produto': random.choice(produtos),
            'categoria': random.choice(categorias),
            'preco': round(random.uniform(50, 2000), 2),
            'quantidade': random.randint(1, 10),
            'desconto': round(random.uniform(0, 0.3), 2),
            'regiao': random.choice(regioes),
            'vendedor_id': random.randint(1, 50),
            'data_venda': f"2024-{random.randint(1,12):02d}-{random.randint(1,28):02d}",
            'satisfacao': round(random.uniform(1, 5), 1)
        }
        
        # Calcular valor total
        registro['valor_total'] = round(
            registro['preco'] * registro['quantidade'] * (1 - registro['desconto']), 2
        )
        
        # Adicionar alguns valores nulos (5% dos dados)
        if random.random() < 0.05:
            campo_nulo = random.choice(['satisfacao', 'desconto'])
            registro[campo_nulo] = None
            
        dados.append(registro)
    
    print(f"‚úÖ {len(dados)} registros gerados com sucesso!")
    return dados

def analisar_dados_simples(dados):
    """An√°lise simples dos dados sem depend√™ncias complexas"""
    print("\nüìä INICIANDO AN√ÅLISE DOS DADOS")
    print("=" * 50)
    
    total_registros = len(dados)
    print(f"üìà Total de registros: {total_registros}")
    
    # An√°lise de vendas por produto
    vendas_por_produto = {}
    vendas_por_regiao = {}
    valores_totais = []
    valores_nao_nulos = []
    
    for registro in dados:
        produto = registro['produto']
        regiao = registro['regiao']
        valor = registro['valor_total']
        
        # Contagem por produto
        if produto in vendas_por_produto:
            vendas_por_produto[produto] += 1
        else:
            vendas_por_produto[produto] = 1
            
        # Contagem por regi√£o
        if regiao in vendas_por_regiao:
            vendas_por_regiao[regiao] += 1
        else:
            vendas_por_regiao[regiao] = 1
            
        # Coleta de valores
        valores_totais.append(valor)
        if registro['satisfacao'] is not None:
            valores_nao_nulos.append(registro['satisfacao'])
    
    # Estat√≠sticas b√°sicas
    if valores_totais:
        valor_medio = sum(valores_totais) / len(valores_totais)
        valor_maximo = max(valores_totais)
        valor_minimo = min(valores_totais)
        
        print(f"\nüí∞ AN√ÅLISE FINANCEIRA:")
        print(f"   üíµ Valor m√©dio por venda: R$ {valor_medio:.2f}")
        print(f"   üìà Maior venda: R$ {valor_maximo:.2f}")
        print(f"   üìâ Menor venda: R$ {valor_minimo:.2f}")
        print(f"   üí∏ Receita total: R$ {sum(valores_totais):.2f}")
    
    # An√°lise por produto
    print(f"\nüõçÔ∏è VENDAS POR PRODUTO:")
    for produto, count in sorted(vendas_por_produto.items(), key=lambda x: x[1], reverse=True):
        percentual = (count / total_registros) * 100
        print(f"   üì¶ {produto}: {count} vendas ({percentual:.1f}%)")
    
    # An√°lise por regi√£o
    print(f"\nüåç VENDAS POR REGI√ÉO:")
    for regiao, count in sorted(vendas_por_regiao.items(), key=lambda x: x[1], reverse=True):
        percentual = (count / total_registros) * 100
        print(f"   üìç {regiao}: {count} vendas ({percentual:.1f}%)")
    
    # An√°lise de satisfa√ß√£o
    if valores_nao_nulos:
        satisfacao_media = sum(valores_nao_nulos) / len(valores_nao_nulos)
        print(f"\n‚≠ê SATISFA√á√ÉO DO CLIENTE:")
        print(f"   üòä Satisfa√ß√£o m√©dia: {satisfacao_media:.2f}/5.0")
        print(f"   üìä Respostas v√°lidas: {len(valores_nao_nulos)}/{total_registros}")
    
    return {
        'total_registros': total_registros,
        'vendas_por_produto': vendas_por_produto,
        'vendas_por_regiao': vendas_por_regiao,
        'valor_medio': valor_medio if valores_totais else 0,
        'receita_total': sum(valores_totais) if valores_totais else 0
    }

def limpeza_dados_simples(dados):
    """Limpeza b√°sica dos dados"""
    print("\nüßπ LIMPEZA DOS DADOS")
    print("=" * 30)
    
    registros_originais = len(dados)
    dados_limpos = []
    
    registros_com_problemas = 0
    
    for registro in dados:
        # Verificar se tem dados essenciais
        if (registro.get('preco', 0) > 0 and 
            registro.get('quantidade', 0) > 0 and
            registro.get('produto') and
            registro.get('regiao')):
            
            # Tratar valores nulos
            if registro.get('satisfacao') is None:
                registro['satisfacao'] = 3.0  # Valor padr√£o neutro
            
            if registro.get('desconto') is None:
                registro['desconto'] = 0.0  # Sem desconto por padr√£o
            
            dados_limpos.append(registro)
        else:
            registros_com_problemas += 1
    
    print(f"   üìä Registros originais: {registros_originais}")
    print(f"   üóëÔ∏è Registros com problemas: {registros_com_problemas}")
    print(f"   ‚úÖ Registros limpos: {len(dados_limpos)}")
    print(f"   üìà Taxa de aproveitamento: {(len(dados_limpos)/registros_originais)*100:.1f}%")
    
    return dados_limpos

def detectar_outliers_simples(dados):
    """Detec√ß√£o simples de outliers"""
    print("\nüîç DETEC√á√ÉO DE OUTLIERS")
    print("=" * 30)
    
    valores = [registro['valor_total'] for registro in dados]
    
    if len(valores) < 4:
        print("   ‚ö†Ô∏è Dados insuficientes para an√°lise de outliers")
        return dados
    
    # M√©todo simples: valores muito acima da m√©dia
    valores_ordenados = sorted(valores)
    q1_index = len(valores_ordenados) // 4
    q3_index = 3 * len(valores_ordenados) // 4
    
    q1 = valores_ordenados[q1_index]
    q3 = valores_ordenados[q3_index]
    iqr = q3 - q1
    
    limite_inferior = q1 - 1.5 * iqr
    limite_superior = q3 + 1.5 * iqr
    
    outliers = []
    dados_sem_outliers = []
    
    for registro in dados:
        valor = registro['valor_total']
        if limite_inferior <= valor <= limite_superior:
            dados_sem_outliers.append(registro)
        else:
            outliers.append(registro)
    
    print(f"   üìä Q1 (25%): R$ {q1:.2f}")
    print(f"   üìä Q3 (75%): R$ {q3:.2f}")
    print(f"   üìè IQR: R$ {iqr:.2f}")
    print(f"   üìâ Limite inferior: R$ {limite_inferior:.2f}")
    print(f"   üìà Limite superior: R$ {limite_superior:.2f}")
    print(f"   ‚ö†Ô∏è Outliers detectados: {len(outliers)}")
    print(f"   ‚úÖ Registros mantidos: {len(dados_sem_outliers)}")
    
    return dados_sem_outliers

def gerar_insights_simples(resultados):
    """Gera insights simples baseados nos resultados"""
    print("\nüí° INSIGHTS E RECOMENDA√á√ïES")
    print("=" * 40)
    
    # Produto mais vendido
    produto_top = max(resultados['vendas_por_produto'].items(), key=lambda x: x[1])
    print(f"üèÜ Produto campe√£o: {produto_top[0]} ({produto_top[1]} vendas)")
    
    # Regi√£o mais forte
    regiao_top = max(resultados['vendas_por_regiao'].items(), key=lambda x: x[1])
    print(f"üåü Regi√£o l√≠der: {regiao_top[0]} ({regiao_top[1]} vendas)")
    
    # An√°lise de receita
    if resultados['receita_total'] > 0:
        print(f"üí∞ Ticket m√©dio: R$ {resultados['valor_medio']:.2f}")
        
        if resultados['valor_medio'] > 500:
            print("   üí° Alto valor m√©dio - foque em produtos premium")
        elif resultados['valor_medio'] < 200:
            print("   üí° Baixo valor m√©dio - oportunidade para upselling")
        else:
            print("   üí° Valor m√©dio equilibrado - mantenha estrat√©gia")
    
    # Distribui√ß√£o de produtos
    total_vendas = sum(resultados['vendas_por_produto'].values())
    produtos_concentrados = 0
    
    for produto, vendas in resultados['vendas_por_produto'].items():
        if vendas / total_vendas > 0.3:  # Mais de 30%
            produtos_concentrados += 1
    
    if produtos_concentrados > 0:
        print("   ‚ö†Ô∏è Concentra√ß√£o alta em poucos produtos - diversifique!")
    else:
        print("   ‚úÖ Boa distribui√ß√£o de vendas entre produtos")

def salvar_resultados(resultados):
    """Salva resultados em arquivo JSON"""
    try:
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"analise_vendas_{timestamp}.json"
        
        # Preparar dados para JSON
        dados_para_salvar = {
            'timestamp': timestamp,
            'analise': resultados,
            'metadata': {
                'total_registros': resultados['total_registros'],
                'bibliotecas_usadas': {
                    'pandas': HAS_PANDAS,
                    'numpy': HAS_NUMPY,
                    'matplotlib': HAS_MATPLOTLIB
                }
            }
        }
        
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(dados_para_salvar, f, indent=2, ensure_ascii=False)
        
        print(f"\nüíæ Resultados salvos em: {filename}")
        return filename
        
    except Exception as e:
        print(f"\n‚ùå Erro ao salvar: {e}")
        return None

def pipeline_completo_simples():
    """Executa o pipeline completo de forma simples e robusta"""
    print("üöÄ PIPELINE SIMPLES DE AN√ÅLISE DE DADOS")
    print("=" * 60)
    print("‚ú® Vers√£o simplificada - 100% funcional")
    print("=" * 60)
    
    try:
        # 1. Gera√ß√£o de dados
        dados_brutos = gerar_dados_vendas(1000)
        
        # 2. Limpeza
        dados_limpos = limpeza_dados_simples(dados_brutos)
        
        # 3. Remo√ß√£o de outliers
        dados_finais = detectar_outliers_simples(dados_limpos)
        
        # 4. An√°lise
        resultados = analisar_dados_simples(dados_finais)
        
        # 5. Insights
        gerar_insights_simples(resultados)
        
        # 6. Salvar resultados
        salvar_resultados(resultados)
        
        print("\nüéâ PIPELINE EXECUTADO COM SUCESSO!")
        print("=" * 50)
        print("üìä Resumo da execu√ß√£o:")
        print(f"   üìà Registros processados: {resultados['total_registros']}")
        print(f"   üí∞ Receita analisada: R$ {resultados['receita_total']:.2f}")
        print(f"   üõçÔ∏è Produtos √∫nicos: {len(resultados['vendas_por_produto'])}")
        print(f"   üåç Regi√µes analisadas: {len(resultados['vendas_por_regiao'])}")
        
        return True
        
    except Exception as e:
        print(f"\n‚ùå ERRO NO PIPELINE: {e}")
        print("‚ö†Ô∏è Pipeline interrompido, mas opera√ß√µes parciais podem ter sido realizadas.")
        return False

# Conceitos educacionais
def mostrar_conceitos():
    """Mostra conceitos fundamentais de an√°lise de dados"""
    print("\nüìö CONCEITOS FUNDAMENTAIS DE AN√ÅLISE DE DADOS")
    print("=" * 60)
    
    conceitos = {
        "üìä Explora√ß√£o de Dados (EDA)": [
            "Entender a estrutura e qualidade dos dados",
            "Identificar padr√µes, tend√™ncias e anomalias",
            "Calcular estat√≠sticas descritivas b√°sicas",
            "Visualizar distribui√ß√µes e relacionamentos"
        ],
        "üßπ Limpeza de Dados": [
            "Identificar e tratar valores nulos/ausentes",
            "Detectar e remover outliers quando apropriado",
            "Padronizar formatos e encoding",
            "Validar consist√™ncia e integridade"
        ],
        "üìà An√°lise Estat√≠stica": [
            "Medidas de tend√™ncia central (m√©dia, mediana)",
            "Medidas de dispers√£o (desvio padr√£o, vari√¢ncia)",
            "An√°lise de correla√ß√µes entre vari√°veis",
            "Distribui√ß√µes e testes de normalidade"
        ],
        "üí° Gera√ß√£o de Insights": [
            "Identificar padr√µes de neg√≥cio relevantes",
            "Formular hip√≥teses baseadas em dados",
            "Propor a√ß√µes baseadas em evid√™ncias",
            "Comunicar resultados de forma clara"
        ]
    }
    
    for categoria, itens in conceitos.items():
        print(f"\n{categoria}")
        for item in itens:
            print(f"   ‚Ä¢ {item}")

def main():
    """Fun√ß√£o principal"""
    print("üéØ AULA 05: Pipeline Completo de An√°lise de Dados")
    print("Autor: Professor Vagner Cordeiro")
    print("=" * 60)
    
    # Mostrar conceitos
    mostrar_conceitos()
    
    # Executar pipeline
    print(f"\nüéì DEMONSTRA√á√ÉO: Pipeline de An√°lise de Dados")
    print("=" * 60)
    
    sucesso = pipeline_completo_simples()
    
    if sucesso:
        print("\n‚úÖ Aula conclu√≠da! Pipeline executado com sucesso.")
    else:
        print("\n‚ö†Ô∏è Aula conclu√≠da com problemas. Revise os logs acima.")

if __name__ == "__main__":
    main()
